<!DOCTYPE html>
<html>

<head>
    <title>Face prep</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        textarea {
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 14px;
            border: none;
            outline: none;
            resize: none;
        }
    </style>
</head>

<body>
    <textarea rows="20" cols="80">
        bfs :
        import java.util.LinkedList;
        import java.util.Queue;
        import java.util.Scanner;
        
        class Graph {
            int vertices;
            LinkedList<Integer>[] adjList;
        
            @SuppressWarnings("unchecked") Graph(int vertices) {
                this.vertices = vertices;
                adjList = new LinkedList[vertices];
                for (int i = 0; i < vertices; ++i)
                    adjList[i] = new LinkedList<>();
            }
        
            void addEdge(int u, int v) {
                adjList[u].add(v);
            }
        
            void bfs(int startNode) {
                Queue<Integer> queue = new LinkedList<>();
                boolean[] visited = new boolean[vertices];
        
                visited[startNode] = true;
                queue.add(startNode);
        
                while (!queue.isEmpty()) {
                    int currentNode = queue.poll();
                    System.out.print(currentNode + " ");
                    for (int neighbor : adjList[currentNode]) {
                        if (!visited[neighbor]) {
                            visited[neighbor] = true;
                            queue.add(neighbor);
                        }
                    }
                }
            }
        }
        
        public class bfs {
            public static void main(String[] args) {
                Scanner scanner = new Scanner(System.in);
                System.out.print("Enter the number of vertices: ");
                int vertices = scanner.nextInt();
        
                Graph graph = new Graph(vertices);
        
                System.out.print("Enter the number of edges: ");
                int edges = scanner.nextInt();
        
                System.out.println("Enter the edges in the format: <vertex1> <vertex2>");
                for (int i = 0; i < edges; ++i) {
                    int u = scanner.nextInt();
                    int v = scanner.nextInt();
                    graph.addEdge(u, v);
                }
                System.out.print("Breadth First Traversal starting  ");
                graph.bfs(0);
        
                scanner.close();
            }
        }


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


dfs:
import java.util.LinkedList;
import java.util.Scanner;
import java.util.Stack;

class Graph {
    int vertices;
    LinkedList<Integer>[] adjList;

    @SuppressWarnings("unchecked") Graph(int vertices) {
        this.vertices = vertices;
        adjList = new LinkedList[vertices];
        for (int i = 0; i < vertices; ++i)
            adjList[i] = new LinkedList<>();
    }

    void addEdge(int u, int v) {
        adjList[u].add(v);
    }

    void dfs(int startNode) {
        Stack<Integer> stack = new Stack<>();
        boolean[] visited = new boolean[vertices];

        stack.push(startNode);

        while (!stack.isEmpty()) 
        {
            int currentNode = stack.pop();
            if (!visited[currentNode]) {
                visited[currentNode] = true;
                System.out.print(currentNode + " ");

                for (int neighbor : adjList[currentNode]) {
                    if (!visited[neighbor]) {
                        stack.push(neighbor);
                    }
                }
            }
        }
    }
}

public class dfs {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of vertices: ");
        int vertices = scanner.nextInt();

        Graph graph = new Graph(vertices);

        System.out.print("Enter the number of edges: ");
        int edges = scanner.nextInt();

        System.out.println("Enter the edges in the format: <vertex1> <vertex2>");
        for (int i = 0; i < edges; ++i) {
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            graph.addEdge(u, v);
        }

        System.out.print("Depth First Traversal starting from vertex 0: ");
        graph.dfs(0);

        scanner.close();
    }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



Binomial heap :

import java.util.*;
class BinomialHeapNode {
    int key, degree;
    BinomialHeapNode parent;
    BinomialHeapNode sibling;
    BinomialHeapNode child;
    public BinomialHeapNode(int k){
        key = k;
        degree = 0;
        parent = null;
        sibling = null;
        child = null;
    }
    public BinomialHeapNode reverse(BinomialHeapNode sibl){
        BinomialHeapNode ret;
        if (sibling != null)
            ret = sibling.reverse(this);
        else
            ret = this;
        sibling = sibl;
        return ret;
    }
    public BinomialHeapNode findMinNode(){
        BinomialHeapNode x = this, y = this;
        int min = x.key;
        while (x != null) {
            if (x.key < min) {
                y = x;
                min = x.key;
            }
            x = x.sibling;
        }
        return y;
    }
    public BinomialHeapNode findANodeWithKey(int value){
        BinomialHeapNode temp = this, node = null;
        while (temp != null) {
            if (temp.key == value) {
                node = temp;
                break;
            }
            if (temp.child == null)
                temp = temp.sibling;
            else {
                node = temp.child.findANodeWithKey(value);
                if (node == null)
                    temp = temp.sibling;
                else
                    break;
            }
        }
        return node;
    }
    public int getSize(){
        return (1 + ((child == null) ? 0 : child.getSize())+ ((sibling == null) ? 0 : sibling.getSize()));
    }
}
class BinomialHeap {
    private BinomialHeapNode Nodes;
    private int size;
    public BinomialHeap(){
        Nodes = null;
        size = 0;
    }

    public boolean isEmpty() {
        return Nodes == null;
    }
    public int getSize() {
        return size;
    }
    public void makeEmpty(){
        Nodes = null;
        size = 0;
    }
    public void insert(int value){
        if (value > 0) {
            BinomialHeapNode temp = new BinomialHeapNode(value);
            if (Nodes == null) {
                Nodes = temp;
                size = 1;
            }
            else {
                unionNodes(temp);size++;
            }
        }
    }
    private void merge(BinomialHeapNode binHeap){
        BinomialHeapNode temp1 = Nodes, temp2 = binHeap;
        while ((temp1 != null) && (temp2 != null)) {
            if (temp1.degree == temp2.degree) {
                BinomialHeapNode tmp = temp2;
                temp2 = temp2.sibling;
                tmp.sibling = temp1.sibling;
                temp1.sibling = tmp;
                temp1 = tmp.sibling;
            }
            else {
                if (temp1.degree < temp2.degree) {
                    if ((temp1.sibling == null) || (temp1.sibling.degree > temp2.degree)){
                        BinomialHeapNode tmp = temp2;
                        temp2 = temp2.sibling;
                        tmp.sibling = temp1.sibling;
                        temp1.sibling = tmp;
                        temp1 = tmp.sibling;
                    }

                    else
                        temp1 = temp1.sibling;
                }
                else {
                    BinomialHeapNode tmp = temp1;
                    temp1 = temp2;
                    temp2 = temp2.sibling;
                    temp1.sibling = tmp;
                    if (tmp == Nodes)
                        Nodes = temp1;
                }
            }
        }
        if (temp1 == null) {
            temp1 = Nodes;
            while (temp1.sibling != null)
                temp1 = temp1.sibling;
            temp1.sibling = temp2;
        }
    }
    private void unionNodes(BinomialHeapNode binHeap){
        merge(binHeap);
        BinomialHeapNode prevTemp = null, temp = Nodes, nextTemp =Nodes.sibling;
        while (nextTemp != null) {
            if ((temp.degree != nextTemp.degree) || ((nextTemp.sibling != null) && (nextTemp.sibling.degree == 	temp.degree))){
                prevTemp = temp;
                temp = nextTemp;
            }
            else {
                if (temp.key <= nextTemp.key) {
                    temp.sibling = nextTemp.sibling;
                    nextTemp.parent = temp;
                    nextTemp.sibling = temp.child;
                    temp.child = nextTemp;
                    temp.degree++;
                }
                else {
                    if (prevTemp == null)
                        Nodes = nextTemp;
                    else
                        prevTemp.sibling = nextTemp;
                    temp.parent = nextTemp;
                    temp.sibling = nextTemp.child;
                    nextTemp.child = temp;
                    nextTemp.degree++;
                    temp = nextTemp;
                }
            }
            nextTemp = temp.sibling;
        }
    }
    public int findMinimum(){
        return Nodes.findMinNode().key;
    }
    public void delete(int value){
        if ((Nodes!=null) && (Nodes.findANodeWithKey(value)!=null)){
            decreaseKeyValue(value, findMinimum() - 1);
            extractMin();
        }
    }
    public void decreaseKeyValue(int old_value,int new_value){
        BinomialHeapNode temp = Nodes.findANodeWithKey(old_value);
        if (temp == null)
            return;
        temp.key = new_value;
        BinomialHeapNode tempParent = temp.parent;
        while ((tempParent != null)	&& (temp.key < tempParent.key)) {
            int z = temp.key;
            temp.key = tempParent.key;
            tempParent.key = z;
            temp = tempParent;
            tempParent = tempParent.parent;
        }
    }
    public int extractMin(){
        if (Nodes == null)
            return -1;
        BinomialHeapNode temp = Nodes, prevTemp = null;
        BinomialHeapNode minNode = Nodes.findMinNode();

        while (temp.key != minNode.key) {
            prevTemp = temp;
            temp = temp.sibling;
        }
        if (prevTemp == null)
            Nodes = temp.sibling;
        else
            prevTemp.sibling = temp.sibling;
        temp = temp.child;
        BinomialHeapNode fakeNode = temp;
        while (temp != null) {
            temp.parent = null;
            temp = temp.sibling;
        }
        if ((Nodes == null) && (fakeNode == null))
            size = 0;
        else {
            if ((Nodes == null) && (fakeNode != null)) {
                Nodes = fakeNode.reverse(null);
                size = Nodes.getSize();
            }
            else {
                if ((Nodes != null) && (fakeNode == null))
                    size = Nodes.getSize();
                else {
                    unionNodes(fakeNode.reverse(null));
                    size = Nodes.getSize();
                }
            }
        }
        return minNode.key;
    }
    public void displayHeap(){
        System.out.print("\nHeap : ");displayHeap(Nodes);
        System.out.println("\n");
    }
    private void displayHeap(BinomialHeapNode r){
        if (r != null) {
            displayHeap(r.child);System.out.print(r.key + " ");
            displayHeap(r.sibling);
        }
    }
}
public class binomial_heap {
    public static void main(String[] args){
        BinomialHeap binHeap = new BinomialHeap();
        Scanner s=new Scanner(System.in);
        int n=s.nextInt();
        for(int i=0; i<n; i++)
            binHeap.insert(s.nextInt());
        System.out.println("Size:" + binHeap.getSize());
        binHeap.displayHeap();
        binHeap.delete(s.nextInt());
        System.out.println("Size:" + binHeap.getSize());
        binHeap.displayHeap();
        System.out.println(binHeap.isEmpty());
        binHeap.makeEmpty();
        System.out.println(binHeap.isEmpty());
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


bellman ford:
import java.util.*;

class bellman {
    class Edge {
        int src, dest, weight;
        Edge() {
            src = dest = weight = 0;
        }
    };

    int V, E;
    Edge edge[];

    bellman(int v, int e) {
        V = v;
        E = e;
        edge = new Edge[E]; // Change here
        for (int i = 0; i < E; ++i) // And here
            edge[i] = new Edge();
    }

    void BellmanFord(bellman graph, int src) {
        int V = graph.V, E = graph.E;
        int dist[] = new int[V];

        for (int i = 0; i < V; ++i)
            dist[i] = Integer.MAX_VALUE;

        dist[src] = 0;

        for (int i = 1; i < V; ++i) {
            for (int j = 0; j < E; ++j) {
                int u = graph.edge[j].src;
                int v = graph.edge[j].dest;
                int weight = graph.edge[j].weight;
                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v])
                    dist[v] = dist[u] + weight;
            }
        }

        for (int j = 0; j < E; ++j) {
            int u = graph.edge[j].src;
            int v = graph.edge[j].dest;
            int weight = graph.edge[j].weight;
            if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                System.out.println(-1);
                return;
            }
        }

        for (int i = 0; i < V; ++i)
            if (dist[i] != Integer.MAX_VALUE)
                System.out.print(dist[i] + " ");
            else
                System.out.print(-1 + " ");
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int V = s.nextInt();
        int E = s.nextInt(); // Read E before creating the graph
        bellman graph = new bellman(V, E);

        for (int i = 0; i < E; i++) {
            int u = s.nextInt();
            int v = s.nextInt();
            int w = s.nextInt();
            graph.edge[i].src = u;
            graph.edge[i].dest = v;
            graph.edge[i].weight = w;
        }

        graph.BellmanFord(graph, 0);
    }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


kary:
import java.util.*;

class kary {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        int[] arr = new int[n+1];
        for (int i = 0; i < n; i++)
            arr[i] = s.nextInt();
        int k = s.nextInt();
        buildHeap(arr, n, k);
        System.out.println("Built Heap: ");
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + " ");
        int element = s.nextInt();
        insert(arr, n, k, element);
        n++;
        System.out.println("\nHeap after insertion of " + element + ": ");
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + " ");
        System.out.println("\nExtracted max is " + extractMax(arr, n, k));
        n--;
        System.out.println("\n\nHeap after extract max: ");
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + " ");
    }

    public static void buildHeap(int[] arr, int n, int k) {
        for (int i = (n - 1) / k; i >= 0; i--)
            restoreDown(arr, n, i, k);
    }

    public static void insert(int[] arr, int n, int k, int elem) {
        arr[n] = elem; // Insert the element at the end of the array
        restoreUp(arr, n, k);
    }

    public static int extractMax(int[] arr, int n, int k) {
        int max = arr[0];
        arr[0] = arr[n - 1];
        restoreDown(arr, n - 1, 0, k);
        return max;
    }

    public static void restoreDown(int[] arr, int len, int index, int k) {
        int[] child = new int[k + 1];
        while (true) {
            for (int i = 1; i <= k; i++)
                child[i] = (k * index + i) < len ? (k * index + i) : -1;
            int maxChild = -1, maxChildIndex = 0;
            for (int i = 1; i <= k; i++) {
                if (child[i] != -1 && arr[child[i]] > maxChild) {
                    maxChildIndex = child[i];
                    maxChild = arr[child[i]];
                }
            }
            if (maxChild == -1)
                break;
            if (arr[index] < arr[maxChildIndex])
                swap(arr, index, maxChildIndex);
            index = maxChildIndex;
        }
    }

    public static void restoreUp(int[] arr, int index, int k) {
        int parent = (index - 1) / k;
        while (parent >= 0) {
            if (arr[index] > arr[parent]) {
                swap(arr, index, parent);
                index = parent;
                parent = (index - 1) / k;
            } else
                break;
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



heap sort:
import java.util.*;
public class heap_sort {
	public static void sort(int arr[]){
		int N=arr.length;
		for(int i=N/2-1; i>=0; i--)
			heapify(arr,N,i);
		for(int i=N-1; i>0; i--) {
			int temp=arr[0];
			arr[0]=arr[i];
			arr[i]=temp;
			heapify(arr,i,0);
		}
	}
    static void heapify(int arr[], int N, int i)
    {
		int largest=i; 
		int l=2*i+1; 
		int r=2*i+2; 
		if(l<N && arr[l]>arr[largest])
			largest=l;
		if(r<N && arr[r]>arr[largest])
			largest=r;
            if(largest!=i) {
                int swap=arr[i];
                arr[i]=arr[largest];
                arr[largest]=swap;
                heapify(arr,N,largest);
            }
        }
        public static void main(String args[]){
            Scanner s=new Scanner(System.in);
            int n=s.nextInt();
            int arr[] = new int[n];
            for(int i=0; i<n; i++)
                arr[i]=s.nextInt();
            sort(arr);
            System.out.println("Sorted array is");
            for(int i=0; i<n; i++)
                System.out.print(arr[i] + " ");
            System.out.println();
        }
    }


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    course_scheduling:
    import java.util.*;
    
    class course_scheduling {
        private boolean detectCycleUtil(List<List<Integer>> adj, int[] visited, int v) {
            if (visited[v] == 1)
                return true;
            if (visited[v] == 2)
                return false;
    
            visited[v] = 1;
            for (int i = 0; i < adj.get(v).size(); ++i)
                if (detectCycleUtil(adj, visited, adj.get(v).get(i)))
                    return true;
    
            visited[v] = 2; 
            return false;
        }
    
        // Cycle detection
        private boolean detectCycle(List<List<Integer>> adj, int n) {
            int[] visited = new int[n];
            for (int i = 0; i < n; ++i)
                if (visited[i] == 0)
                    if (detectCycleUtil(adj, visited, i))
                        return true;
            return false;
        }
    
        // Topological sort
        private void dfs(List<List<Integer>> adj, int v, boolean[] visited, Stack<Integer> mystack) {
            visited[v] = true;
            for (int i = 0; i < adj.get(v).size(); ++i)
                if (!visited[adj.get(v).get(i)])
                    dfs(adj, adj.get(v).get(i), visited, mystack);
    
            mystack.push(v);
        }
    
        public int[] findOrder(int numCourses, int[][] prerequisites) {
            int maxCourse = 0;
            for (int i = 0; i < prerequisites.length; ++i) {
                maxCourse = Math.max(maxCourse, Math.max(prerequisites[i][0], prerequisites[i][1]));
            }
            maxCourse++;
    
            List<List<Integer>> adj = new ArrayList<>();
            for (int i = 0; i < maxCourse; i++)
                adj.add(new ArrayList<>());
    
            for (int i = 0; i < prerequisites.length; ++i)
                adj.get(prerequisites[i][1]).add(prerequisites[i][0]);
    
            int[] ans = new int[numCourses];
            if (detectCycle(adj, maxCourse))
                return new int[0];
    
            Stack<Integer> mystack = new Stack<>();
            boolean[] visited = new boolean[maxCourse];
    
            for (int i = 0; i < maxCourse; ++i)
                if (!visited[i])
                    dfs(adj, i, visited, mystack);
    
            int index = 0;
            while (!mystack.isEmpty()) {
                ans[index++] = mystack.pop();
            }
            return ans;
        }
    
        public static void main(String[] args) {
            course_scheduling solution = new course_scheduling();
            Scanner scanner = new Scanner(System.in);
    
            System.out.print("Enter the number of courses: ");
            int numCourses = scanner.nextInt();
    
            System.out.print("Enter the number of prerequisites: ");
            int n = scanner.nextInt();
            int[][] prerequisites = new int[n][2];
    
            System.out.println("Enter prerequisite pairs (course, prerequisite):");
            for (int i = 0; i < n; i++) {
                prerequisites[i][0] = scanner.nextInt();
                prerequisites[i][1] = scanner.nextInt();
            }
    
            int[] result = solution.findOrder(numCourses, prerequisites);
            System.out.println("Topological order of courses:");
            System.out.println(Arrays.toString(result));
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

boundary traversal:

import java.util.*;

class Node {
    int data;
    Node left, right;

    public Node(int data) {
        this.data = data;
        left = right = null;
    }
}

class boundary {
    static Node root;

    static Node build(String s[]) {
        if (s[0] == "N" || s.length == 0)
            return null;
        Node root = new Node(Integer.parseInt(s[0]));
        Queue<Node> q = new LinkedList<Node>();
        q.add(root);
        int i = 1;
        while (!q.isEmpty() && i < s.length) {
            Node curr = q.poll();
            String cval = s[i];
            if (!cval.equals("N")) {
                int h = Integer.parseInt(cval);
                curr.left = new Node(h);
                q.add(curr.left);
            }
            i++;
            if (i >= s.length)
                break;
            cval = s[i];
            if (!cval.equals("N")) {
                int h = Integer.parseInt(cval);
                curr.right = new Node(h);
                q.add(curr.right);
            }
            i++;
        }
        return root;
    }

    // print the leaves
    void printLeaves(Node node) {
        if (node == null)
            return;
        printLeaves(node.left);
        if (node.left == null && node.right == null)
            System.out.print(node.data + " ");
        printLeaves(node.right);
    }

    // left boundary
    void printBoundaryLeft(Node node) {
        if (node == null)
            return;
        if (node.left != null) {
            System.out.print(node.data + " ");
            printBoundaryLeft(node.left);
        } else if (node.right != null) {
            System.out.print(node.data + " ");
            printBoundaryLeft(node.right);
        }
    }

    // right boundary
    void printBoundaryRight(Node node) {
        if (node == null)
            return;
        if (node.right != null) {
            printBoundaryRight(node.right);
            System.out.print(node.data + " ");
        } else if (node.left != null) {
            printBoundaryRight(node.left);
            System.out.print(node.data + " ");
        }
    }

    void printBoundary(Node node) {
        if (node == null)
            return;
        System.out.print(node.data + " ");
        printBoundaryLeft(node.left);
        printLeaves(node.left);
        printLeaves(node.right);
        printBoundaryRight(node.right);
    }

    // main method
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        boundary ob = new boundary();
        String s[] = sc.nextLine().split(" ");
        root = build(s);
        ob.printBoundary(root);
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

winner tree:
import java.util.*;
class Node {
	int idx;
	Node left, right;
}
class winner {
	static Node createNode(int idx) {
		Node t = new Node();
		t.left = t.right = null;
		t.idx = idx;
		return t;
	}
	static void traverseHeight(Node root, int[] arr, int[] res) {
		if (root == null || (root.left == null && root.right == null))
			return;
		if (res[0] > arr[root.left.idx] && root.left.idx != root.idx) {
			res[0] = arr[root.left.idx];
			traverseHeight(root.right, arr, res);
		}
        else if(res[0]>arr[root.right.idx]&& root.right.idx!=root.idx){
			res[0] = arr[root.right.idx];
			traverseHeight(root.left, arr, res);
		}
	}
	static void findSecondMin(int[] arr, int n) {
		List<Node> li = new LinkedList<>();
		Node root = null;
		for (int i = 0; i < n; i += 2) {
			Node t1 = createNode(i);
			Node t2 = null;
			if (i + 1 < n) {
				t2 = createNode(i + 1);
				root = (arr[i] < arr[i + 1]) ? createNode(i) : createNode(i + 1);
				root.left = t1;
				root.right = t2;
				li.add(root);
			} 
			else
				li.add(t1);
		}
        int lsize = li.size();
		while (lsize != 1) {
			int last = (lsize & 1) == 1 ? lsize - 2 : lsize - 1;
			for (int i = 0; i < last; i += 2) {
				Node f1 = li.remove(0);
				Node f2 = li.remove(0);
				root = (arr[f1.idx] < arr[f2.idx]) ? createNode(f1.idx) : createNode(f2.idx);
				root.left = f1;
				root.right = f2;
				li.add(root);
			}
			if ((lsize & 1) == 1) {
				li.add(li.get(0));
				li.remove(0);
			}
			lsize = li.size();
		}
        int[] res = {Integer.MAX_VALUE};
		traverseHeight(root, arr, res);
		System.out.println("Minimum: " + arr[root.idx] + ", Second minimum: " + res[0]);
	}
	public static void main(String[] args) {
	    Scanner s=new Scanner(System.in);
	    int n=s.nextInt();
	    int arr[] = new int[n];
	    for(int i=0; i<n; i++)
		arr[i]=s.nextInt();
	    findSecondMin(arr, n);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

vertical:
import java.util.*;
import java.util.Map.Entry;
class Node {
    int data;
    Node left, right;
    public Node(int data){
        this.data = data;
        left = right = null;
    }
}

class vertical {
    static Node root;
    private List<Integer> path1 = new ArrayList<>();
    private List<Integer> path2 = new ArrayList<>();
    static Node build(String s[]){
        if(s[0]=="N"||s.length==0)
            return null;
        Node root=new Node(Integer.parseInt(s[0]));
	  Queue<Node> q=new LinkedList<Node>();
        q.add(root);
        int i=1;
        while(!q.isEmpty() && i<s.length){
            Node curr=q.poll();
            String cval=s[i];
            if(!cval.equals("N")){
                int h=Integer.parseInt(cval);
                curr.left=new Node(h);
                q.add(curr.left);
            }
            i++;
            if(i >= s.length)
                break;
            cval = s[i];
               if(!cval.equals("N")){
                   int h=Integer.parseInt(cval);
                   curr.right=new Node(h);
                   q.add(curr.right);
               }
               i++;
           }
           return root;
	}
    static void preOrderTraversal(Node root, long hd, long vd,TreeMap<Long, Vector<Integer> > m){
        if (root == null)
            return;
        long val = hd << 30 | vd;
        if (m.get(val) != null)
            m.get(val).add(root.data);
        else {
            Vector<Integer> v = new Vector<Integer>();
            v.add(root.data);
            m.put(val, v);
        }
        preOrderTraversal(root.left, hd - 1, vd + 1, m);
        preOrderTraversal(root.right, hd + 1, vd + 1, m);
    }

    void verticalOrder(Node root){
        TreeMap<Long, Vector<Integer> > mp = new TreeMap<>();
        preOrderTraversal(root, 0, 1, mp);
        int prekey = Integer.MAX_VALUE;
        for (Entry<Long, Vector<Integer> > entry :mp.entrySet()) {
            if(prekey!=Integer.MAX_VALUE && (entry.getKey()>>30)!= prekey)
                System.out.println();
            prekey = (int)(entry.getKey() >> 30);
            for (int x : entry.getValue())
                System.out.print(x + " ");
        }
    }
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int i;
        Main ob = new Main();
        String s[]=sc.nextLine().split(" ");
        root = build(s);
        ob.verticalOrder(root);
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

view of tree:

import java.util.*;
import java.util.Map.Entry;

class Node {
    int data, hd;
    Node left, right;

    public Node(int data) {
        this.data = data;
        left = right = null;
        this.hd = Integer.MAX_VALUE;
    }
}

class view{
    static Node root;
    private List<Integer> path1 = new ArrayList<>();
    private List<Integer> path2 = new ArrayList<>();

    static Node build(String s[]) {
        if (s[0] == "N" || s.length == 0)
            return null;
        Node root = new Node(Integer.parseInt(s[0]));
        Queue<Node> q = new LinkedList<Node>();
        q.add(root);
        int i = 1;
        while (!q.isEmpty() && i < s.length) {
            Node curr = q.poll();
            String cval = s[i];
            if (!cval.equals("N")) {
                int h = Integer.parseInt(cval);
                curr.left = new Node(h);
                q.add(curr.left);
            }
            i++;
            if (i >= s.length)
                break;
            cval = s[i];
            if (!cval.equals("N")) {
                int h = Integer.parseInt(cval);
                curr.right = new Node(h);
                q.add(curr.right);
            }
            i++;
        }
        return root;
    }

// Right View
void rightview(Node root) {
    if (root == null)
        return;
    Queue<Node> q = new LinkedList<>();
    q.add(root);
    while (!q.isEmpty()) {
        int n = q.size();
        Node rightmost = null; // Initialize rightmost to null for each level
        for (int i = 0; i < n; i++) {
            Node curr = q.poll();
            rightmost = curr; // Update rightmost for the current level
            if (curr.left != null)
                q.add(curr.left);
            if (curr.right != null)
                q.add(curr.right);
        }
        System.out.print(rightmost.data + " "); // Print the rightmost node for the current level
    }
}

    // Left View
    void leftview(Node root) {
        if (root == null)
            return;
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int n = queue.size();
            for (int i = 1; i <= n; i++) {
                Node temp = queue.poll();
                if (i == 1)
                    System.out.print(temp.data + " ");
                if (temp.left != null)
                    queue.add(temp.left);
                if (temp.right != null)
                    queue.add(temp.right);
            }
        }
    }

    // Top View
    static class QueueObj {
        Node node;
        int hd;

        QueueObj(Node node, int hd) {
            this.node = node;
            this.hd = hd;
        }
    }

    static void topview(Node root) {
        if (root == null)
            return;
        Queue<QueueObj> q = new LinkedList<>();
        Map<Integer, Integer> map = new HashMap<>();
        int min = 0;
        int max = 0;
        q.add(new QueueObj(root, 0));
        while (!q.isEmpty()) {
            QueueObj curr = q.poll();
            if (!map.containsKey(curr.hd))
                map.put(curr.hd, curr.node.data);
            if (curr.node.left != null) {
                min = Math.min(min, curr.hd - 1);
                q.add(new QueueObj(curr.node.left, curr.hd - 1));
            }
            if (curr.node.right != null) {
                max = Math.max(max, curr.hd + 1);
                q.add(new QueueObj(curr.node.right, curr.hd + 1));
            }
        }
        for (; min <= max; min++)
            System.out.print(map.get(min) + " ");
    }

    // Bottom View
    static void bottomview(Node root) {
        if (root == null)
            return;
        int hd = 0;
        Map<Integer, Integer> map = new TreeMap<>();
        Queue<Node> queue = new LinkedList<Node>();
        root.hd = hd;
        queue.add(root);
        while (!queue.isEmpty()) {
            Node temp = queue.remove();
            hd = temp.hd;
            map.put(hd, temp.data);
            if (temp.left != null) {
                temp.left.hd = hd - 1;
                queue.add(temp.left);
            }
            if (temp.right != null) {
                temp.right.hd = hd + 1;
                queue.add(temp.right);
            }
        }
        Set<Entry<Integer, Integer>> set = map.entrySet();
        Iterator<Entry<Integer, Integer>> iterator = set.iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, Integer> me = iterator.next();
            System.out.print(me.getValue() + " ");
        }
    }

    // main method
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        view ob = new view();
        String s[] = sc.nextLine().split(" ");
        root = build(s);
        ob.rightview(root);
        System.out.println();
        ob.leftview(root);
        System.out.println();
        topview(root);
        System.out.println();
        bottomview(root);
        sc.close();
    }
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

toposort:

import java.util.*;

public class toposort {
    static void topologicalSortUtil(int v, List<List<Integer>> adj, boolean[] visited, Stack<Integer> stack) 
    {
        visited[v] = true;
        for (int i : adj.get(v)) {
            if (!visited[i])
                topologicalSortUtil(i, adj, visited, stack);
        }
        stack.push(v);
    }

    static void topologicalSort(List<List<Integer>> adj, int V) {
        Stack<Integer> stack = new Stack<>(); 
        boolean[] visited = new boolean[V];
        for (int i = 0; i < V; i++) {
            if (!visited[i])
                topologicalSortUtil(i, adj, visited, stack);
        }

        System.out.print("Topological sorting of the graph: ");
        while (!stack.empty()) {
            System.out.print(stack.pop() + " ");
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of nodes: ");
        int V = sc.nextInt();
        System.out.print("Enter the number of edges: ");
        int E = sc.nextInt();
        List<List<Integer>> adj = new ArrayList<>(V);
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }
        System.out.println("Enter the edges (from to):");
        for (int i = 0; i < E; i++) {
            int from = sc.nextInt();
            int to = sc.nextInt();
            adj.get(from).add(to);
        }
        topologicalSort(adj, V);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Recovery BST:
import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
        left = null;
        right = null;
    }
}

class BSTRecoverer {
    TreeNode first;
    TreeNode second;
    TreeNode prev;

    void recoverTree(TreeNode root) {
        // Initialize the variables
        first = null;
        second = null;
        prev = new TreeNode(Integer.MIN_VALUE);

        // In-order traversal to find the misplaced nodes
        inorderTraversal(root);

        // Swap the values of the misplaced nodes
        int temp = first.val;
        first.val = second.val;
        second.val = temp;
    }

    void inorderTraversal(TreeNode root) {
        if (root == null) {
            return;
        }

        inorderTraversal(root.left);

        // Check for misplaced nodes
        if (first == null && prev.val > root.val) {
            first = prev;
        }
        if (first != null && prev.val > root.val) {
            second = root;
        }
        prev = root;

        inorderTraversal(root.right);
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Create the BST from user input
        String input = scanner.nextLine();
        String[] values = input.split(" ");
        TreeNode root = buildBST(values);

        // Recover the BST
        BSTRecoverer recoverer = new BSTRecoverer();
        recoverer.recoverTree(root);
        printInorder(root);
    }

    static TreeNode buildBST(String[] values) {
        int n = values.length;
        if (n == 0) {
            return null;
        }

        TreeNode[] nodes = new TreeNode[n];
        for (int i = 0; i < n; i++) {
            if (!values[i].equals("N")) {
                nodes[i] = new TreeNode(Integer.parseInt(values[i]));
            }
        }

        TreeNode root = nodes[0];
        for (int i = 0; i < n; i++) {
            TreeNode parent = nodes[i];
            if (parent != null) {
                int leftIndex = 2 * i + 1;
                int rightIndex = 2 * i + 2;
                if (leftIndex < n) {
                    parent.left = nodes[leftIndex];
                }
                if (rightIndex < n) {
                    parent.right = nodes[rightIndex];
                }
            }
        }

        return root;
    }

    static void printInorder(TreeNode root) {
        if (root == null) {
            return;
        }

        printInorder(root.left);
        System.out.print(root.val + " ");
        printInorder(root.right);
    }
}

    </textarea>
</body>

</html>
